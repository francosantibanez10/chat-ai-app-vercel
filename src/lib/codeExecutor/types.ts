import { z } from "zod";

// Schemas de validaci√≥n
export const codeExecutionSchema = z.object({
  id: z.string(),
  userId: z.string(),
  language: z.enum([
    "python",
    "javascript",
    "sql",
    "bash",
    "typescript",
    "java",
    "cpp",
    "go",
  ]),
  code: z.string().min(1),
  input: z.any().optional(),
  output: z.any().optional(),
  error: z.string().optional(),
  executionTime: z.number().min(0),
  memoryUsage: z.number().min(0),
  timestamp: z.date(),
  isSandboxed: z.boolean(),
  resourceLimits: z.object({
    maxExecutionTime: z.number().min(100).max(30000),
    maxMemoryUsage: z.number().min(1).max(1000),
    maxOutputSize: z
      .number()
      .min(1024)
      .max(10 * 1024 * 1024),
    allowNetworkAccess: z.boolean(),
    allowFileSystemAccess: z.boolean(),
    maxCpuUsage: z.number().min(1).max(100).optional(),
    maxDiskUsage: z
      .number()
      .min(1024)
      .max(100 * 1024 * 1024)
      .optional(),
  }),
  metadata: z
    .object({
      complexity: z.number().min(1).max(10).optional(),
      securityScore: z.number().min(0).max(1).optional(),
      performanceScore: z.number().min(0).max(1).optional(),
      testCoverage: z.number().min(0).max(1).optional(),
      codeHash: z.string().optional(),
      embeddings: z.array(z.number()).optional(),
      suggestions: z.array(z.string()).optional(),
      warnings: z.array(z.string()).optional(),
    })
    .optional(),
});

export const codeAnalysisSchema = z.object({
  language: z.string(),
  complexity: z.number().min(1).max(10),
  cyclomaticComplexity: z.number().min(1).optional(),
  potentialIssues: z.array(z.string()),
  suggestions: z.array(z.string()),
  securityScore: z.number().min(0).max(1),
  performanceScore: z.number().min(0).max(1),
  maintainabilityScore: z.number().min(0).max(1).optional(),
  codeStyleScore: z.number().min(0).max(1).optional(),
  bestPractices: z.array(z.string()).optional(),
  refactoringSuggestions: z.array(z.string()).optional(),
});

export const testCaseSchema = z.object({
  input: z.any(),
  expectedOutput: z.any(),
  description: z.string(),
  category: z.enum(["unit", "integration", "edge", "performance"]).optional(),
  timeout: z.number().min(100).max(10000).optional(),
});

export const autoGeneratedTestsSchema = z.object({
  testCases: z.array(testCaseSchema),
  coverage: z.number().min(0).max(1),
  confidence: z.number().min(0).max(1),
  testFramework: z.string().optional(),
  executionTime: z.number().optional(),
});

export const debugResultSchema = z.object({
  fixedCode: z.string(),
  explanation: z.string(),
  confidence: z.number().min(0).max(1),
  originalError: z.string(),
  appliedFixes: z.array(z.string()).optional(),
  suggestions: z.array(z.string()).optional(),
});

export const securityReportSchema = z.object({
  threatLevel: z.enum(["low", "medium", "high", "critical"]),
  vulnerabilities: z.array(
    z.object({
      type: z.string(),
      description: z.string(),
      severity: z.enum(["low", "medium", "high", "critical"]),
      line: z.number().optional(),
      suggestion: z.string(),
    })
  ),
  sanitizedCode: z.string(),
  isSafe: z.boolean(),
  securityScore: z.number().min(0).max(1),
});

export const performanceReportSchema = z.object({
  executionTime: z.number(),
  memoryUsage: z.number(),
  cpuUsage: z.number().optional(),
  complexity: z.number(),
  bottlenecks: z.array(z.string()).optional(),
  optimizations: z.array(z.string()).optional(),
  performanceScore: z.number().min(0).max(1),
});

// Interfaces principales
export interface CodeExecution extends z.infer<typeof codeExecutionSchema> {}

export interface CodeAnalysis extends z.infer<typeof codeAnalysisSchema> {}

export interface TestCase extends z.infer<typeof testCaseSchema> {}

export interface AutoGeneratedTests
  extends z.infer<typeof autoGeneratedTestsSchema> {}

export interface DebugResult extends z.infer<typeof debugResultSchema> {}

export interface SecurityReport extends z.infer<typeof securityReportSchema> {}

export interface PerformanceReport
  extends z.infer<typeof performanceReportSchema> {}

export interface ResourceLimits {
  maxExecutionTime: number; // ms
  maxMemoryUsage: number; // MB
  maxOutputSize: number; // bytes
  allowNetworkAccess: boolean;
  allowFileSystemAccess: boolean;
  maxCpuUsage?: number; // percentage
  maxDiskUsage?: number; // bytes
}

export interface ExecutionContext {
  userId: string;
  sessionId?: string;
  requestId?: string;
  environment?: "development" | "staging" | "production";
  priority?: "low" | "normal" | "high" | "critical";
}

export interface ExecutionOptions {
  resourceLimits?: Partial<ResourceLimits>;
  context?: ExecutionContext;
  enableAnalysis?: boolean;
  enableTests?: boolean;
  enableDebugging?: boolean;
  enableSecurityCheck?: boolean;
  enablePerformanceMonitoring?: boolean;
  timeout?: number;
  retryAttempts?: number;
}

export interface ExecutionResult {
  execution: CodeExecution;
  analysis?: CodeAnalysis;
  tests?: AutoGeneratedTests;
  securityReport?: SecurityReport;
  performanceReport?: PerformanceReport;
  debugResult?: DebugResult;
  metadata: {
    executionId: string;
    timestamp: Date;
    duration: number;
    success: boolean;
    warnings: string[];
  };
}

export interface CodePattern {
  id: string;
  codeHash: string;
  language: string;
  pattern: string;
  embeddings: number[];
  usageCount: number;
  successRate: number;
  averageExecutionTime: number;
  lastUsed: Date;
  tags: string[];
  metadata: Record<string, any>;
}

export interface ExecutionStats {
  totalExecutions: number;
  successfulExecutions: number;
  failedExecutions: number;
  averageExecutionTime: number;
  averageMemoryUsage: number;
  mostUsedLanguage: string;
  securityIncidents: number;
  performanceIssues: number;
  testCoverage: number;
  codeQualityScore: number;
  languageBreakdown: Record<string, number>;
  errorBreakdown: Record<string, number>;
  timeSeriesData: Array<{
    date: string;
    executions: number;
    errors: number;
    avgTime: number;
  }>;
}

export interface SandboxConfig {
  timeout: number;
  memoryLimit: number;
  cpuLimit: number;
  networkAccess: boolean;
  fileSystemAccess: boolean;
  allowedModules: string[];
  blockedModules: string[];
  environment: Record<string, string>;
}

export interface CodeExecutorConfig {
  defaultResourceLimits: ResourceLimits;
  sandboxConfig: SandboxConfig;
  enableLogging: boolean;
  enableMetrics: boolean;
  enableSecurityChecks: boolean;
  enablePerformanceMonitoring: boolean;
  maxConcurrentExecutions: number;
  cleanupInterval: number;
  retentionPeriod: number;
  logLevel: "debug" | "info" | "warn" | "error";
}
