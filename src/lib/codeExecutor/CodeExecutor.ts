import { z } from "zod";
import {
  CodeExecution,
  CodeAnalysis,
  AutoGeneratedTests,
  DebugResult,
  SecurityReport,
  PerformanceReport,
  ResourceLimits,
  ExecutionContext,
  ExecutionOptions,
  ExecutionResult,
  CodePattern,
  ExecutionStats,
  CodeExecutorConfig,
  codeExecutionSchema,
  codeAnalysisSchema,
  autoGeneratedTestsSchema,
  debugResultSchema,
} from "./types";
import { securityManager } from "./SecurityManager";
import { sandboxManager } from "./SandboxManager";
import { executionAnalyzer } from "./ExecutionAnalyzer";
import { testGenerator } from "../TestGenerator";
import { executionLogger } from "../ExecutionLogger";
import { performanceMonitor } from "../performanceMonitor";
import { cacheManager } from "../cacheManager";
import { codeMemory } from "../CodeMemory";

// Logger estructurado
class Logger {
  static info(message: string, data?: any) {
    console.log(
      JSON.stringify({
        level: "info",
        timestamp: new Date().toISOString(),
        component: "CodeExecutor",
        message,
        ...data,
      })
    );
  }

  static error(message: string, error?: any) {
    console.error(
      JSON.stringify({
        level: "error",
        timestamp: new Date().toISOString(),
        component: "CodeExecutor",
        message,
        error: error?.message || error,
      })
    );
  }

  static warn(message: string, data?: any) {
    console.warn(
      JSON.stringify({
        level: "warn",
        timestamp: new Date().toISOString(),
        component: "CodeExecutor",
        message,
        ...data,
      })
    );
  }
}

export class CodeExecutor {
  private static instance: CodeExecutor;
  private executions: Map<string, CodeExecution[]> = new Map();
  private config: CodeExecutorConfig;
  private isInitialized: boolean = false;

  private constructor() {
    this.config = {
      defaultResourceLimits: {
        maxExecutionTime: 5000,
        maxMemoryUsage: 50,
        maxOutputSize: 1024 * 1024,
        allowNetworkAccess: false,
        allowFileSystemAccess: false,
        maxCpuUsage: 50,
        maxDiskUsage: 10 * 1024 * 1024,
      },
      sandboxConfig: {
        timeout: 5000,
        memoryLimit: 50,
        cpuLimit: 50,
        networkAccess: false,
        fileSystemAccess: false,
        allowedModules: [],
        blockedModules: [],
        environment: {},
      },
      enableLogging: true,
      enableMetrics: true,
      enableSecurityChecks: true,
      enablePerformanceMonitoring: true,
      maxConcurrentExecutions: 10,
      cleanupInterval: 300000, // 5 minutos
      retentionPeriod: 30 * 24 * 60 * 60 * 1000, // 30 días
      logLevel: "info",
    };
  }

  static getInstance(): CodeExecutor {
    if (!CodeExecutor.instance) {
      CodeExecutor.instance = new CodeExecutor();
    }
    return CodeExecutor.instance;
  }

  /**
   * Inicializar el CodeExecutor
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      // Configurar sandbox
      sandboxManager.configureSandbox(this.config.sandboxConfig);

      // Iniciar limpieza automática
      this.startAutoCleanup();

      // Verificar salud de componentes
      await this.healthCheck();

      this.isInitialized = true;
      Logger.info("CodeExecutor initialized successfully");
    } catch (error) {
      Logger.error("Error initializing CodeExecutor", { error });
      throw error;
    }
  }

  /**
   * Ejecutar código de forma segura y completa
   */
  async executeCode(
    userId: string,
    language: string,
    code: string,
    input?: any,
    options: ExecutionOptions = {}
  ): Promise<ExecutionResult> {
    const startTime = Date.now();
    const executionId = `${userId}-${Date.now()}-${Math.random()
      .toString(36)
      .substr(2, 9)}`;

    try {
      // Asegurar inicialización
      if (!this.isInitialized) {
        await this.initialize();
      }

      // Validar entradas
      const validatedCode = z.string().min(1).max(100000).parse(code);
      const validatedLanguage = z
        .enum([
          "python",
          "javascript",
          "sql",
          "bash",
          "typescript",
          "java",
          "cpp",
          "go",
        ])
        .parse(language);

      // Configurar límites de recursos
      const resourceLimits: ResourceLimits = {
        ...this.config.defaultResourceLimits,
        ...options.resourceLimits,
      };

      // Contexto de ejecución
      const context: ExecutionContext = {
        userId,
        sessionId: options.context?.sessionId,
        requestId: executionId,
        environment: options.context?.environment || "production",
        priority: options.context?.priority || "normal",
      };

      // Crear ejecución base
      const execution: CodeExecution = {
        id: executionId,
        userId,
        language: validatedLanguage,
        code: validatedCode,
        input,
        executionTime: 0,
        memoryUsage: 0,
        timestamp: new Date(),
        isSandboxed: true,
        resourceLimits,
      };

      // Ejecutar en sandbox
      const sandboxResult = await this.executeInSandbox(
        validatedCode,
        validatedLanguage,
        input,
        resourceLimits,
        context
      );

      // Actualizar ejecución con resultados
      execution.output = sandboxResult.output;
      execution.error = sandboxResult.error;
      execution.executionTime = Date.now() - startTime;
      execution.memoryUsage = sandboxResult.memoryUsage;

      // Analizar el código si está habilitado
      let analysis: CodeAnalysis | undefined;
      if (options.enableAnalysis) {
        analysis = await executionAnalyzer.analyzeCode(
          validatedCode,
          validatedLanguage
        );
      }

      // Generar tests si está habilitado y la ejecución fue exitosa
      let tests: AutoGeneratedTests | undefined;
      if (options.enableTests && !sandboxResult.error) {
        tests = await testGenerator.generateTests(
          validatedCode,
          validatedLanguage,
          {
            context: options.context,
          }
        );
      }

      // Verificar seguridad si está habilitado
      let securityReport: SecurityReport | undefined;
      if (options.enableSecurityCheck) {
        securityReport = await securityManager.analyzeSecurity(
          validatedCode,
          validatedLanguage,
          context
        );
      }

      // Monitorear rendimiento si está habilitado
      let performanceReport: PerformanceReport | undefined;
      if (options.enablePerformanceMonitoring) {
        performanceReport = await executionAnalyzer.analyzePerformance(
          execution,
          context
        );
      }

      // Guardar patrón en memoria si la ejecución fue exitosa
      if (!sandboxResult.error) {
        await codeMemory.storePattern(
          validatedCode,
          validatedLanguage,
          execution,
          context
        );
      }

      // Guardar ejecución
      await this.saveExecution(execution);

      // Logging
      if (this.config.enableLogging) {
        await executionLogger.logExecution(execution, context);
      }

      // Métricas
      if (this.config.enableMetrics) {
        performanceMonitor.recordMetric(
          "code_execution",
          execution.executionTime,
          !sandboxResult.error,
          undefined,
          {
            executionId,
            language: validatedLanguage,
            memoryUsage: sandboxResult.memoryUsage,
            userId,
          }
        );
      }

      const result: ExecutionResult = {
        execution,
        analysis,
        tests,
        securityReport,
        performanceReport,
        metadata: {
          executionId,
          timestamp: new Date(),
          duration: Date.now() - startTime,
          success: !sandboxResult.error,
          warnings: [],
        },
      };

      Logger.info("Code execution completed", {
        executionId,
        language: validatedLanguage,
        success: !sandboxResult.error,
        executionTime: execution.executionTime,
        memoryUsage: sandboxResult.memoryUsage,
      });

      return result;
    } catch (error) {
      Logger.error("Code execution failed", { executionId, error });

      // Registrar error
      performanceMonitor.recordError(
        "code_execution",
        error instanceof Error ? error.message : "Unknown error"
      );

      // Retornar resultado con error
      const failedExecution: CodeExecution = {
        id: executionId,
        userId,
        language: language as any,
        code,
        input,
        error: error instanceof Error ? error.message : "Unknown error",
        executionTime: Date.now() - startTime,
        memoryUsage: 0,
        timestamp: new Date(),
        isSandboxed: true,
        resourceLimits: this.config.defaultResourceLimits,
      };

      return {
        execution: failedExecution,
        metadata: {
          executionId,
          timestamp: new Date(),
          duration: Date.now() - startTime,
          success: false,
          warnings: [error instanceof Error ? error.message : "Unknown error"],
        },
      };
    }
  }

  /**
   * Ejecutar código en sandbox
   */
  private async executeInSandbox(
    code: string,
    language: string,
    input: any,
    limits: ResourceLimits,
    context: ExecutionContext
  ): Promise<{ output: any; memoryUsage: number; error?: string }> {
    switch (language.toLowerCase()) {
      case "javascript":
      case "typescript":
        return await sandboxManager.executeJavaScript(
          code,
          input,
          limits,
          context
        );
      case "python":
        return await sandboxManager.executePython(code, input, limits, context);
      case "sql":
        return await sandboxManager.executeSQL(code, input, limits, context);
      case "bash":
        return await sandboxManager.executeBash(code, input, limits, context);
      default:
        throw new Error(`Lenguaje no soportado: ${language}`);
    }
  }

  /**
   * Depurar código automáticamente
   */
  async debugCode(
    code: string,
    language: string,
    error: string,
    input?: any,
    context?: ExecutionContext
  ): Promise<DebugResult> {
    const startTime = Date.now();

    try {
      // Analizar el error
      const analysis = await executionAnalyzer.analyzeCode(code, language);

      // Generar código corregido (simulado)
      const fixedCode = code; // Por ahora, no implementamos generateFix

      // Verificar que el código corregido funciona
      const testResult = await this.executeCode(
        context?.userId || "debug",
        language,
        fixedCode,
        input,
        { enableAnalysis: false, enableTests: false }
      );

      const debugResult: DebugResult = {
        fixedCode,
        explanation: `Error corregido: ${error}`,
        confidence: testResult.metadata.success ? 0.9 : 0.5,
        originalError: error,
        appliedFixes: [error],
        suggestions: analysis?.suggestions || [],
      };

      // Registrar métricas
      performanceMonitor.recordMetric(
        "code_debugged",
        Date.now() - startTime,
        testResult.metadata.success,
        undefined,
        { language }
      );

      return debugResult;
    } catch (debugError) {
      Logger.error("Code debugging failed", { error: debugError });

      return {
        fixedCode: code,
        explanation: "No se pudo corregir el código",
        confidence: 0.0,
        originalError: error,
        appliedFixes: [],
        suggestions: [],
      };
    }
  }

  /**
   * Buscar patrones similares
   */
  async findSimilarPatterns(
    query: string,
    language: string,
    limit: number = 5
  ): Promise<CodePattern[]> {
    try {
      const similarPatterns = await codeMemory.findSimilarPatterns(
        query,
        language,
        {
          limit,
          threshold: 0.7,
        }
      );

      // Convertir SimilarityResult[] a CodePattern[]
      return similarPatterns.map((result) => result.pattern);
    } catch (error) {
      Logger.error("Failed to find similar patterns", { error });
      return [];
    }
  }

  /**
   * Obtener ejecuciones de un usuario
   */
  async getUserExecutions(
    userId: string,
    limit: number = 50,
    options?: { language?: string; success?: boolean }
  ): Promise<CodeExecution[]> {
    try {
      const userExecutions = this.executions.get(userId) || [];

      let filteredExecutions = userExecutions;

      // Filtrar por lenguaje
      if (options?.language) {
        filteredExecutions = filteredExecutions.filter(
          (exec) => exec.language === options.language
        );
      }

      // Filtrar por éxito
      if (options?.success !== undefined) {
        filteredExecutions = filteredExecutions.filter(
          (exec) => (exec.error === undefined) === options.success
        );
      }

      // Ordenar por timestamp (más reciente primero)
      filteredExecutions.sort(
        (a, b) => b.timestamp.getTime() - a.timestamp.getTime()
      );

      // Limitar resultados
      return filteredExecutions.slice(0, limit);
    } catch (error) {
      Logger.error("Failed to get user executions", { error, userId });
      return [];
    }
  }

  /**
   * Obtener estadísticas completas
   */
  async getExecutionStats(): Promise<ExecutionStats> {
    try {
      const allExecutions: CodeExecution[] = [];
      for (const userExecutions of this.executions.values()) {
        allExecutions.push(...userExecutions);
      }

      const totalExecutions = allExecutions.length;
      const successfulExecutions = allExecutions.filter(
        (exec) => !exec.error
      ).length;
      const failedExecutions = totalExecutions - successfulExecutions;

      const averageExecutionTime =
        allExecutions.length > 0
          ? allExecutions.reduce((sum, exec) => sum + exec.executionTime, 0) /
            allExecutions.length
          : 0;

      const averageMemoryUsage =
        allExecutions.length > 0
          ? allExecutions.reduce((sum, exec) => sum + exec.memoryUsage, 0) /
            allExecutions.length
          : 0;

      // Análisis por lenguaje
      const languageBreakdown: Record<string, number> = {};
      allExecutions.forEach((exec) => {
        languageBreakdown[exec.language] =
          (languageBreakdown[exec.language] || 0) + 1;
      });

      const mostUsedLanguage =
        Object.entries(languageBreakdown).sort(
          ([, a], [, b]) => b - a
        )[0]?.[0] || "";

      // Análisis de errores
      const errorBreakdown: Record<string, number> = {};
      allExecutions
        .filter((exec) => exec.error)
        .forEach((exec) => {
          const errorType = exec.error?.split(":")[0] || "Unknown";
          errorBreakdown[errorType] = (errorBreakdown[errorType] || 0) + 1;
        });

      // Datos de series temporales
      const timeSeriesData = this.generateTimeSeriesData(allExecutions);

      // Estadísticas de seguridad y sandbox
      const securityStats = securityManager.getSecurityStats();
      const sandboxStats = sandboxManager.getSandboxStats();
      const memoryStats = codeMemory.getStats();

      // Estadísticas de memoria de código
      const averageTestCoverage = 0.75; // Valor por defecto

      const stats: ExecutionStats = {
        totalExecutions,
        successfulExecutions,
        failedExecutions,
        averageExecutionTime,
        averageMemoryUsage,
        mostUsedLanguage,
        securityIncidents: securityStats.blockedExecutions,
        performanceIssues: 0, // Implementar cálculo
        testCoverage: averageTestCoverage,
        codeQualityScore: 0.8, // Implementar cálculo
        languageBreakdown,
        errorBreakdown,
        timeSeriesData,
      };

      return stats;
    } catch (error) {
      Logger.error("Failed to get execution stats", { error });
      return {
        totalExecutions: 0,
        successfulExecutions: 0,
        failedExecutions: 0,
        averageExecutionTime: 0,
        averageMemoryUsage: 0,
        mostUsedLanguage: "",
        securityIncidents: 0,
        performanceIssues: 0,
        testCoverage: 0,
        codeQualityScore: 0,
        languageBreakdown: {},
        errorBreakdown: {},
        timeSeriesData: [],
      };
    }
  }

  async healthCheck(): Promise<{
    status: "healthy" | "degraded" | "unhealthy";
    components: {
      sandbox: any;
      security: any;
      analyzer: any;
      memory: any;
      cache: any;
    };
    details: string;
  }> {
    try {
      const components = {
        sandbox: await sandboxManager.healthCheck(),
        security: { status: "healthy" }, // SecurityManager no tiene healthCheck
        analyzer: { status: "healthy" }, // ExecutionAnalyzer no tiene healthCheck
        memory: { status: "healthy" }, // CodeMemory no tiene healthCheck
        cache: await cacheManager.healthCheck(),
      };

      const healthyComponents = Object.values(components).filter(
        (c) => c.status === "healthy"
      ).length;
      const totalComponents = Object.keys(components).length;

      let status: "healthy" | "degraded" | "unhealthy";
      if (healthyComponents === totalComponents) {
        status = "healthy";
      } else if (healthyComponents >= totalComponents * 0.7) {
        status = "degraded";
      } else {
        status = "unhealthy";
      }

      return {
        status,
        components,
        details: `${healthyComponents}/${totalComponents} components healthy`,
      };
    } catch (error) {
      Logger.error("Health check failed", { error });
      return {
        status: "unhealthy",
        components: {
          sandbox: { status: "unhealthy", error: "Health check failed" },
          security: { status: "unhealthy", error: "Health check failed" },
          analyzer: { status: "unhealthy", error: "Health check failed" },
          memory: { status: "unhealthy", error: "Health check failed" },
          cache: { status: "unhealthy", error: "Health check failed" },
        },
        details: "Health check failed",
      };
    }
  }

  /**
   * Configurar el CodeExecutor
   */
  configure(config: Partial<CodeExecutorConfig>): void {
    this.config = { ...this.config, ...config };
    Logger.info("CodeExecutor configuration updated", { config: this.config });
  }

  /**
   * Limpiar ejecuciones antiguas
   */
  cleanupOldExecutions(maxAgeDays: number = 30): void {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);

    let totalCleaned = 0;
    for (const [userId, executions] of this.executions.entries()) {
      const originalCount = executions.length;
      const filteredExecutions = executions.filter(
        (e) => e.timestamp > cutoffDate
      );
      this.executions.set(userId, filteredExecutions);
      totalCleaned += originalCount - filteredExecutions.length;
    }

    Logger.info("Cleanup completed", { totalCleaned, cutoffDate });
  }

  /**
   * Métodos privados de utilidad
   */
  private async saveExecution(execution: CodeExecution): Promise<void> {
    if (!this.executions.has(execution.userId)) {
      this.executions.set(execution.userId, []);
    }
    this.executions.get(execution.userId)!.push(execution);

    // Guardar en caché para acceso rápido
    const cacheKey = `execution:${execution.id}`;
    await cacheManager.set(cacheKey, execution, {
      prefix: "executions",
      ttl: 3600, // 1 hora
    });
  }

  private startAutoCleanup(): void {
    setInterval(() => {
      this.cleanupOldExecutions();
    }, this.config.cleanupInterval);
  }

  private generateTimeSeriesData(executions: CodeExecution[]): Array<{
    date: string;
    executions: number;
    errors: number;
    avgTime: number;
  }> {
    const last30Days = Array.from({ length: 30 }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - i);
      return date.toISOString().split("T")[0];
    }).reverse();

    return last30Days.map((date) => {
      const dayExecutions = executions.filter((e) =>
        e.timestamp.toISOString().startsWith(date)
      );

      return {
        date,
        executions: dayExecutions.length,
        errors: dayExecutions.filter((e) => e.error).length,
        avgTime:
          dayExecutions.length > 0
            ? dayExecutions.reduce((sum, e) => sum + e.executionTime, 0) /
              dayExecutions.length
            : 0,
      };
    });
  }

  private hashCode(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
}

export const codeExecutor = CodeExecutor.getInstance();
