import { streamText } from "ai";
import { openai } from "@ai-sdk/openai";

export interface CodeExecution {
  id: string;
  userId: string;
  language: "python" | "javascript" | "sql" | "bash" | "typescript";
  code: string;
  input?: any;
  output?: any;
  error?: string;
  executionTime: number;
  memoryUsage: number;
  timestamp: Date;
  isSandboxed: boolean;
  resourceLimits: ResourceLimits;
}

export interface ResourceLimits {
  maxExecutionTime: number; // ms
  maxMemoryUsage: number; // MB
  maxOutputSize: number; // bytes
  allowNetworkAccess: boolean;
  allowFileSystemAccess: boolean;
}

export interface CodeAnalysis {
  language: string;
  complexity: number;
  potentialIssues: string[];
  suggestions: string[];
  securityScore: number; // 0-1
  performanceScore: number; // 0-1
}

export interface TestCase {
  input: any;
  expectedOutput: any;
  description: string;
}

export interface AutoGeneratedTests {
  testCases: TestCase[];
  coverage: number;
  confidence: number;
}

export class CodeExecutor {
  private static instance: CodeExecutor;
  private executions: Map<string, CodeExecution[]> = new Map();
  private sandboxEnvironments: Map<string, any> = new Map();

  private constructor() {}

  static getInstance(): CodeExecutor {
    if (!CodeExecutor.instance) {
      CodeExecutor.instance = new CodeExecutor();
    }
    return CodeExecutor.instance;
  }

  /**
   * Ejecutar código de forma segura
   */
  async executeCode(
    userId: string,
    language: string,
    code: string,
    input?: any,
    resourceLimits?: Partial<ResourceLimits>
  ): Promise<CodeExecution> {
    const startTime = Date.now();
    const executionId = `${userId}-${Date.now()}`;

    // Configurar límites por defecto
    const limits: ResourceLimits = {
      maxExecutionTime: 5000, // 5 segundos
      maxMemoryUsage: 50, // 50MB
      maxOutputSize: 1024 * 1024, // 1MB
      allowNetworkAccess: false,
      allowFileSystemAccess: false,
      ...resourceLimits,
    };

    const execution: CodeExecution = {
      id: executionId,
      userId,
      language: language as any,
      code,
      input,
      executionTime: 0,
      memoryUsage: 0,
      timestamp: new Date(),
      isSandboxed: true,
      resourceLimits: limits,
    };

    try {
      // Analizar código antes de ejecutar
      const analysis = await this.analyzeCode(code, language);

      // Verificar seguridad
      if (analysis.securityScore < 0.7) {
        throw new Error(
          `Código potencialmente inseguro. Score: ${analysis.securityScore}`
        );
      }

      // Ejecutar en sandbox
      const result = await this.executeInSandbox(code, language, input, limits);

      execution.output = result.output;
      execution.executionTime = Date.now() - startTime;
      execution.memoryUsage = result.memoryUsage || 0;

      // Generar tests automáticamente si es exitoso
      if (!result.error) {
        const tests = await this.generateTests(code, language, result.output);
        // Asegurarse de que 'metadata' exista y sea un objeto
        (execution as any).metadata = { tests };
      }
    } catch (error) {
      execution.error =
        error instanceof Error ? error.message : "Error desconocido";
      execution.executionTime = Date.now() - startTime;
    }

    // Guardar ejecución
    if (!this.executions.has(userId)) {
      this.executions.set(userId, []);
    }
    this.executions.get(userId)!.push(execution);

    return execution;
  }

  /**
   * Ejecutar código en sandbox
   */
  private async executeInSandbox(
    code: string,
    language: string,
    input: any,
    limits: ResourceLimits
  ): Promise<{ output: any; memoryUsage: number; error?: string }> {
    // Simulación de sandbox - en producción usaría VM2 o similar
    const startTime = Date.now();

    try {
      let output: any;
      let memoryUsage = 0;

      switch (language.toLowerCase()) {
        case "javascript":
        case "typescript":
          output = await this.executeJavaScript(code, input, limits);
          break;
        case "python":
          output = await this.executePython(code, input, limits);
          break;
        case "sql":
          output = await this.executeSQL(code, input, limits);
          break;
        case "bash":
          output = await this.executeBash(code, input, limits);
          break;
        default:
          throw new Error(`Lenguaje no soportado: ${language}`);
      }

      // Verificar límites de tiempo
      if (Date.now() - startTime > limits.maxExecutionTime) {
        throw new Error("Tiempo de ejecución excedido");
      }

      return { output, memoryUsage };
    } catch (error) {
      return {
        output: null,
        memoryUsage: 0,
        error: error instanceof Error ? error.message : "Error en sandbox",
      };
    }
  }

  /**
   * Ejecutar JavaScript/TypeScript
   */
  private async executeJavaScript(
    code: string,
    input: any,
    limits: ResourceLimits
  ): Promise<any> {
    // En producción, usar VM2 para sandbox real
    try {
      // Simulación segura
      const safeCode = this.sanitizeJavaScript(code);
      const result = eval(
        `(function(input) { ${safeCode} })(${JSON.stringify(input)})`
      );
      return result;
    } catch (error) {
      throw new Error(`Error en JavaScript: ${error}`);
    }
  }

  /**
   * Ejecutar Python (simulado)
   */
  private async executePython(
    code: string,
    input: any,
    limits: ResourceLimits
  ): Promise<any> {
    // En producción, usar subprocess con restricciones
    try {
      // Simulación - en realidad se ejecutaría en un proceso separado
      const sanitizedCode = this.sanitizePython(code);
      return { result: "Python execution simulated", input };
    } catch (error) {
      throw new Error(`Error en Python: ${error}`);
    }
  }

  /**
   * Ejecutar SQL
   */
  private async executeSQL(
    code: string,
    input: any,
    limits: ResourceLimits
  ): Promise<any> {
    try {
      // Simulación de ejecución SQL
      const sanitizedSQL = this.sanitizeSQL(code);
      return {
        rows: [{ id: 1, name: "Ejemplo" }],
        count: 1,
        query: sanitizedSQL,
      };
    } catch (error) {
      throw new Error(`Error en SQL: ${error}`);
    }
  }

  /**
   * Ejecutar Bash
   */
  private async executeBash(
    code: string,
    input: any,
    limits: ResourceLimits
  ): Promise<any> {
    try {
      // En producción, usar child_process con restricciones
      const sanitizedBash = this.sanitizeBash(code);
      return {
        stdout: "Bash execution simulated",
        stderr: "",
        exitCode: 0,
      };
    } catch (error) {
      throw new Error(`Error en Bash: ${error}`);
    }
  }

  /**
   * Analizar código
   */
  async analyzeCode(code: string, language: string): Promise<CodeAnalysis> {
    const analysisPrompt = `
Analiza el siguiente código y proporciona un análisis de seguridad y rendimiento:

Lenguaje: ${language}
Código:
\`\`\`${language}
${code}
\`\`\`

Analiza:
1. Complejidad del código
2. Problemas potenciales de seguridad
3. Sugerencias de mejora
4. Score de seguridad (0-1)
5. Score de rendimiento (0-1)

Responde con JSON:
{
  "language": "${language}",
  "complexity": 3,
  "potentialIssues": ["issue1", "issue2"],
  "suggestions": ["suggestion1", "suggestion2"],
  "securityScore": 0.8,
  "performanceScore": 0.7
}`;

    try {
      const result = await streamText({
        model: openai("gpt-4o"),
        messages: [{ role: "user", content: analysisPrompt }],
        temperature: 0.1,
        maxTokens: 400,
      });

      return JSON.parse(await this.getTextSafely(result));
    } catch (error) {
      console.error("Error analyzing code:", error);
      return {
        language,
        complexity: 1,
        potentialIssues: ["Error en análisis"],
        suggestions: ["Revisar código manualmente"],
        securityScore: 0.5,
        performanceScore: 0.5,
      };
    }
  }

  /**
   * Generar tests automáticamente
   */
  async generateTests(
    code: string,
    language: string,
    expectedOutput: any
  ): Promise<AutoGeneratedTests> {
    const testPrompt = `
Genera tests automáticos para este código:

Lenguaje: ${language}
Código:
\`\`\`${language}
${code}
\`\`\`

Output esperado: ${JSON.stringify(expectedOutput)}

Genera casos de prueba que cubran diferentes escenarios.

Responde con JSON:
{
  "testCases": [
    {
      "input": "input1",
      "expectedOutput": "output1",
      "description": "descripción del test"
    }
  ],
  "coverage": 0.8,
  "confidence": 0.9
}`;

    try {
      const result = await streamText({
        model: openai("gpt-4o"),
        messages: [{ role: "user", content: testPrompt }],
        temperature: 0.3,
        maxTokens: 500,
      });

      return JSON.parse(await this.getTextSafely(result));
    } catch (error) {
      console.error("Error generating tests:", error);
      return {
        testCases: [],
        coverage: 0,
        confidence: 0,
      };
    }
  }

  /**
   * Depurar código automáticamente
   */
  async debugCode(
    code: string,
    language: string,
    error: string,
    input?: any
  ): Promise<{ fixedCode: string; explanation: string; confidence: number }> {
    const debugPrompt = `
Depura este código que está fallando:

Lenguaje: ${language}
Código:
\`\`\`${language}
${code}
\`\`\`

Error: ${error}
Input: ${JSON.stringify(input)}

Proporciona el código corregido y una explicación.

Responde con JSON:
{
  "fixedCode": "código corregido",
  "explanation": "explicación del error y la corrección",
  "confidence": 0.9
}`;

    try {
      const result = await streamText({
        model: openai("gpt-4o"),
        messages: [{ role: "user", content: debugPrompt }],
        temperature: 0.3,
        maxTokens: 800,
      });

      return JSON.parse(await this.getTextSafely(result));
    } catch (error) {
      console.error("Error debugging code:", error);
      return {
        fixedCode: code,
        explanation: "Error en depuración automática",
        confidence: 0,
      };
    }
  }

  /**
   * Helper function para obtener texto de manera segura
   */
  private async getTextSafely(result: any): Promise<string> {
    try {
      if (typeof result === "string") {
        return result;
      }
      if (result && typeof result.text === "function") {
        return await result.text();
      }
      return "Error: No se pudo obtener el texto.";
    } catch (error) {
      console.error("Error getting text safely:", error);
      return "Error: No se pudo obtener el texto.";
    }
  }

  /**
   * Sanitizar JavaScript
   */
  private sanitizeJavaScript(code: string): string {
    // Remover funciones peligrosas
    const dangerousFunctions = [
      "eval",
      "Function",
      "setTimeout",
      "setInterval",
      "fetch",
      "XMLHttpRequest",
      "require",
      "import",
    ];

    let sanitized = code;
    dangerousFunctions.forEach((func) => {
      sanitized = sanitized.replace(
        new RegExp(func, "g"),
        `/* ${func} blocked */`
      );
    });

    return sanitized;
  }

  /**
   * Sanitizar Python
   */
  private sanitizePython(code: string): string {
    // Remover imports peligrosos
    const dangerousImports = [
      "os",
      "subprocess",
      "sys",
      "importlib",
      "urllib",
      "requests",
      "socket",
    ];

    let sanitized = code;
    dangerousImports.forEach((module) => {
      sanitized = sanitized.replace(
        new RegExp(`import ${module}`, "g"),
        `# import ${module} blocked`
      );
      sanitized = sanitized.replace(
        new RegExp(`from ${module}`, "g"),
        `# from ${module} blocked`
      );
    });

    return sanitized;
  }

  /**
   * Sanitizar SQL
   */
  private sanitizeSQL(code: string): string {
    // Prevenir SQL injection básico
    const dangerousKeywords = ["DROP", "DELETE", "TRUNCATE", "ALTER", "CREATE"];

    let sanitized = code.toUpperCase();
    dangerousKeywords.forEach((keyword) => {
      if (sanitized.includes(keyword)) {
        throw new Error(`Operación SQL peligrosa detectada: ${keyword}`);
      }
    });

    return code;
  }

  /**
   * Sanitizar Bash
   */
  private sanitizeBash(code: string): string {
    // Remover comandos peligrosos
    const dangerousCommands = [
      "rm -rf",
      "dd",
      "mkfs",
      "fdisk",
      "chmod 777",
      "wget",
      "curl",
      "nc",
      "telnet",
    ];

    let sanitized = code;
    dangerousCommands.forEach((cmd) => {
      if (sanitized.includes(cmd)) {
        throw new Error(`Comando Bash peligroso detectado: ${cmd}`);
      }
    });

    return sanitized;
  }

  /**
   * Obtener ejecuciones de un usuario
   */
  getUserExecutions(userId: string, limit: number = 50): CodeExecution[] {
    const userExecutions = this.executions.get(userId) || [];
    return userExecutions
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, limit);
  }

  /**
   * Obtener estadísticas de ejecución
   */
  getExecutionStats(): {
    totalExecutions: number;
    successfulExecutions: number;
    averageExecutionTime: number;
    mostUsedLanguage: string;
    securityIncidents: number;
  } {
    const allExecutions = Array.from(this.executions.values()).flat();
    const totalExecutions = allExecutions.length;
    const successfulExecutions = allExecutions.filter((e) => !e.error).length;
    const averageExecutionTime =
      allExecutions.length > 0
        ? allExecutions.reduce((sum, e) => sum + e.executionTime, 0) /
          allExecutions.length
        : 0;

    const languageCounts = allExecutions.reduce((acc, e) => {
      acc[e.language] = (acc[e.language] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const mostUsedLanguage =
      Object.entries(languageCounts).sort(([, a], [, b]) => b - a)[0]?.[0] ||
      "N/A";

    const securityIncidents = allExecutions.filter(
      (e) => e.error?.includes("seguridad") || e.error?.includes("security")
    ).length;

    return {
      totalExecutions,
      successfulExecutions,
      averageExecutionTime,
      mostUsedLanguage,
      securityIncidents,
    };
  }

  /**
   * Limpiar ejecuciones antiguas
   */
  cleanupOldExecutions(maxAgeDays: number = 30): void {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);

    for (const [userId, executions] of this.executions.entries()) {
      const filteredExecutions = executions.filter(
        (e) => e.timestamp > cutoffDate
      );
      this.executions.set(userId, filteredExecutions);
    }
  }
}

export const codeExecutor = CodeExecutor.getInstance();
